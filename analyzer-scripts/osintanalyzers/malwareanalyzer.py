from .osintbase import *
from analyzerbase import *

class MalwareAnalyzer(OSINTAnalyzerBase):
    SOURCES = ["malwarebazaar", 
                "urlhaus",
                "threatfox",
                "malpedia",
               ]
    

    def __init__(self, 
                 db_path=Path("tests/mwdb"), 
                 selenium_webdriver_type="chrome", 
                 webdriver_path="/Users/lucasfaudman/Documents/SANS/internship/chromedriver",
                 max_errors={
                        "malwarebazaar": 2,
                        "urlhaus": 2,
                        "threatfox": 2,
                        "malpedia": 2
                    }) -> None:
        
        super().__init__(db_path, selenium_webdriver_type, webdriver_path, max_errors)


    def get_malpedia_names_from_tags(self, tags, ignore_tags=["c2", 'elf', 'win', '32', '64', "win32", "win64", '32-bit', '64-bit', '32bit', '64bit',
                                                              "linux", "linux64", "windows", "mac", "macos", "macosx", "macosx64", "macosx32", "macos64", "macos32",
                                                              "android", "arm", 
                                                              "exe", "dll", "elf32", "elf64", 
                                                              "elf32le", "elf32be", "elf64le", "elf64be", "apk",
                                                              "censys", "jar", "RAT", "rat", "trojan", "Trojan", "backdoor", "Backdoor",
                                                              "loader", "Loader", "downloader", "Downloader", "dropper", "Dropper",
                                                              "SELECTL", "Supershell", "bash", "ssh", "sh", "shell"]):
        malpedia_names = []
        query_tags = set(tags) - set(ignore_tags)
        tags_data = self.get_data(query_tags, arg_type="tag", sources=["threatfox"])
        
        for tag in query_tags:
            for tag_info in tags_data.get(tag, {})["threatfox"].get("results",{}).get("data",[]):
                if tag_info.get("malware_malpedia"):
                    malpedia_names.append(tag_info.get("malware_malpedia", "").split("/")[-1])
 
        return list(set(malpedia_names)) 


    def check_malpedia(self, malpedia_name, arg_type="malpedia_name"):

        malpedia_url = f"https://malpedia.caad.fkie.fraunhofer.de/details/{malpedia_name}"
        response = requests.get(malpedia_url)
        soup = BeautifulSoup(response.text, "html.parser")
        
        
        description = soup.find("meta", {"name": "description"})
        output = self.get_empty_ouput(malpedia_url)
        if description and description.get("content"): 
            output["results"]["description"] = description.get("content")
        else:
            output["error"] = "ERROR: No description found"

        return output


    def _check_abusech(self, api_baseurl="", api_endpoint="", query_type="", query_key="", query_value="", body_format="data"):
        apiurl = 'https://' + api_baseurl + api_endpoint #+ "/"
        data = {query_key : query_value}
        if query_type:
            data["query"] = query_type
            

        request_kwargs = {"url": apiurl,
                          body_format: data
                          }

        response = requests.post(**request_kwargs)
        response_json = response.json()

        output = self.get_empty_ouput()
        
        query_status = response_json.pop("query_status")
        if query_status != "ok":
            output["error"] = "ERROR: " + query_status
            return output
            
        else:
            output["results"] = response_json


        return output


    def check_malwarebazaar(self, fhash, arg_type="hash"):
        if "hash" not in arg_type:
            raise ValueError(f"Invalid arg_type: {arg_type}")

        output = self._check_abusech(
            api_baseurl="mb-api.abuse.ch/api/v1/", 
            api_endpoint="", 
            query_type="get_info", 
            query_key="hash", 
            query_value=fhash,
            body_format="data"
            )

        if output.get("results"):
            output["results"] = output["results"]["data"][0]
            output["sharing_link"] = f"https://bazaar.abuse.ch/sample/{fhash}"

            if output["results"].get("tags"):
                output["results"]["malpedia_names"] = self.get_malpedia_names_from_tags(output["results"]["tags"])

        return output


    def check_urlhaus(self, arg, arg_type="host"):
        if arg_type == "url":
            api_endpoint="url"
            query_key="url"
        
        elif arg_type in ["host", "ip", "domain"]:
            api_endpoint="host"
            query_key="host"

        else:
            raise ValueError(f"Invalid arg_type: {arg_type}")

        output = self._check_abusech(
            api_baseurl="urlhaus-api.abuse.ch/v1/",
            api_endpoint=api_endpoint,
            query_type="",
            query_key=query_key,
            query_value=arg,
            body_format="data")
        
        if output.get("results"):
            output["sharing_link"] = output["results"].pop("urlhaus_reference", "")                    

            if output["results"].get("tags"):
                output["results"]["malpedia_names"] = self.get_malpedia_names_from_tags(output["results"]["tags"])

            for url_item in output["results"].get("urls", []):
                if url_item.get("tags"):
                    url_item["malpedia_names"] = self.get_malpedia_names_from_tags(url_item["tags"])

        return output

    def check_threatfox(self, arg, arg_type="hash"):
        if "hash" in arg_type:
            query_type = "search_hash"
            query_key = "hash"
            url_key = "ioc"
        
        elif arg_type in ["tag", "malware", "malware_name", "malware_family"]:
            arg_type = arg_type.split("_")[0]
            query_type = arg_type + "info"
            query_key = arg_type
            url_key = arg_type

        elif arg_type in ["ioc", "ip", "domain", "url", "host", "ip:port"]:
            query_type = "search_ioc"
            query_key = "search_term"
            url_key = "ioc"

        else:
            raise ValueError(f"Invalid arg_type: {arg_type}")

        output = self._check_abusech(
            api_baseurl="threatfox-api.abuse.ch/api/v1/",
            api_endpoint="",
            query_type=query_type,
            query_key=query_key,
            query_value=arg,
            body_format="json")
        
        if output.get("results"):
            output["sharing_link"] = f"https://threatfox.abuse.ch/browse.php?search={url_key}%3A{arg}"

            if output["results"].get("tags"):
                output["results"]["malpedia_names"] = self.get_malpedia_names_from_tags(output["results"]["tags"])                   

        return output
    
    
    




        
    
    def reduce_malwarebazaar(self, results):
        remove_keys = ["sha256_hash", "sha3_384_hash", "sha1_hash", "md5_hash", 
                        "reporter", "origin_country", "anonymous",
                        "imphash", "tlsh", "telfhash", "gimphash",
                        "ssdeep", "dhash_icon", "archive_pw", 
                        "code_sign", "author", "reference"
                        "twitter_handle", "display_name",
                        "link", "analysis_url", "report_link"
                         ]


        replace_keys = {
            "file_information": "file_context_info",
            "signature": "malware_family",
            "clamav": "clamav_signatures",
            "uploads": "times_uploaded_to_malwarebazaar",
            "downloads": "times_downloaded_from_malwarebazaar",
        }



        reduced_results = recursive_pop(results, remove_keys=remove_keys, replace_keys=replace_keys)

        return reduced_results
    

    def reduce_urlhaus(self, results):
        remove_keys = ["sha256_hash", "sha3_384_hash", "sha1_hash", "md5_hash", 
                        "reporter", "origin_country", "anonymous",
                        "imphash", "tlsh", "telfhash", "gimphash",
                        "ssdeep", "dhash_icon", "archive_pw", 
                        "code_sign", "author", "reference"
                        "twitter_handle", "display_name",
                        "link", "analysis_url", "report_link",
                        "urlhaus_reference", "urlhaus_download",
                        "response_md5", "response_sha256",
                         ]        
        
        
        replace_keys = {
            "firstseen": "first_seen",
            "lastseen": "last_seen",
            "larted": "url_reported_to_hosting_provider",
            "signature": "malware_family",
            "blacklists": "blacklist_statuses",
        }

        url_status_vals = {
            "online": "URL is online and currently serving a payload",
            "offline": "URL is offline and no longer serving a payload",
        }


        spamhaus_vals = {
            "spammer_domain": "URL is a known spammer domain",
            "phishing_domain": "URL is a known phishing domain",
            "botnet_cc_domain": "URL is a known botnet C&C domain",
            "abused_legit_spam": "URL is a known compromised website used for spammer hosting",
            "abused_legit_malware": "URL is a known compromised website used for malware distribution",
            "abused_legit_phishing": "URL is a known compromised website used for phishing hosting",
            "abused_legit_botnetcc": "URL is a known botnet C&C hosting",
            "abused_redirector": "URL is a known abused redirector or URL shortener",
            "not listed": None,
        }

        

        # url_status = results.pop("status", None)
        # if url_status:
        #     results['url_status'] = url_status_vals.get(url_status)

        # blacklists = results.pop("blacklists", None)
        # if blacklists:
        #     if blacklists.get("surbl", ""):
        #         results["surbl_blacklist_status"] = "blacklisted"

        #     if blacklists.get("spamhaus_dbl"):
        #         results["spamhaus_dbl_blacklist_status"] = blacklists.get("spamhaus_dbl")


        reduced_results = recursive_pop(results, 
                                        remove_keys=remove_keys, 
                                        replace_keys=replace_keys,
                                        replace_values={**spamhaus_vals, **url_status_vals}
                                        )
        
        return reduced_results

        



    def reduce_threatfox(self, results):
        remove_keys = ["md5_hash", "reporter", "credits", 
                       "malware_bazaar", "reference"
                        "malware_malpedia"]
        
        replace_keys = {"malware": "malpedia_name"}
        
        return recursive_pop(results, remove_keys=remove_keys, replace_keys=replace_keys)
    

    def reduce_malpedia(self, results):
        reduced_results = recursive_pop(results)

        return reduced_results







    def count_malwarebazaar(self, data, malware):
            
        return data
    

    def count_urlhaus(self, data, malware):

        return data
    


    def count_threatfox(self, data, malware):

        return data

    def count_malpedia(self, data, malware):

        return data
    







if __name__ == '__main__':
    pass